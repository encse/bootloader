; http://www.6502.org/tutorials/6502opcodes.html
; https://sites.google.com/site/6502asembly/6502-instruction-set
    

;https://github.com/meonwax/acme/blob/master/docs/AddrModes.txt
; Applying the byte extraction operators ("<" gives the low byte, ">"
; gives the high byte and "^" gives the bank byte of a value) to any
; value will clear the argument's Force Bits 2 and 3 and set Force
; Bit 1 instead. So "lda <symbol" will use 8-bit addressing, regardless
; of the symbol's Force Bits. Of course, you can change this by
; postfixing the command again... :

    ; * = $0801                               ; BASIC start address (#2049)
    ; !byte $0d,$08,$dc,$07,$9e,$20,$34,$39   ; BASIC loader to start at $c000...
    ; !byte $31,$35,$32,$00,$00,$00           ; puts BASIC line 2012 SYS 49152

KernalPrintYYAA = $AB1E ; prints string located at YYAA
KernalNewLine   = $AAD7 ; prints new line

_fac1_print			= $aabc	; print string representation of contents of fac1
_fac1_to_signedAAYY		= $b1aa	; might throw ILLEGAL QUANTITY
_fac1_to_signed16		= $b1bf	; might throw ILLEGAL QUANTITY
_fac1_read_signedAAYY		= $b391	; convert 16 bit signed int to float
_fac1_read_unsignedY		= $b3a2	; convert 8 bit unsigned int to float
_fac1_read_string		= $b7b5	; $22/23 must point to string, A must be string length
_fac1_to_unsignedAAYY		= $b7f7	; might throw ILLEGAL QUANTITY (result is also in $14/15)
_fac1_add_point5			= $b849	; for rounding, call this before fac1_int
_fac1_memYYAA_minus_fac1		= $b850	; subtract fac1 from mflpt value
_fac1_fac2_minus_fac1		= $b853
_fac1_add_memYYAA		= $b867	; add mflpt value
_fac1_add_fac2			= $b86a
_fac1_log			= $b9ea	; LOG()
_fac1_times_memYYAA		= $ba28	; multiply by mflpt value
_fac2_read_memYYAA		= $ba8c	; load mflpt value from memory into fac2
_fac2_read_mem_via0x22ptr	= $ba90	; load mflpt value from memory into fac2
_fac1_times_10			= $bae2
_fac1_divide_by_10		= $bafe	; CAUTION: result is always positive!
_fac1_divide_memYYAA_by_fac1	= $bb0f	; divide mflpt value by fac1 value
_fac1_read_memYYAA		= $bba2	; load mflpt value from memory into fac1
_fac1_read_mem_via0x22ptr	= $bba6	; load mflpt value from memory into fac1
_fac1_to_memYYXX			= $bbd4	; store fac1 to memory as mflpt
_fac1_read_fac2			= $bbfc	; copy fac2 to fac1
_fac2_read_fac1			= $bc0c	; copy fac1 to fac2
_fac1_sign_to_A			= $bc2b	; $ff, $0, $1 for negative, zero, positive
_fac1_sgn			= $bc39 ; SGN()
_fac1_abs			= $bc58 ; ABS()
_fac1_compare_to_memYYAA		= $bc5b	; compare to mflpt value in memory
_fac1_to_signed32		= $bc9b
_fac1_int			= $bccc ; INT()
_fac1_read_string0		= $bcf3	; use b7b5 instead; this only works after calling CHRGET
_fac1_print_unsignedAAXX		= $bdcd
_fac1_to_string			= $bddd	; string is stored at $0100 (address returned in YYAA)
_fac1_sqr			= $bf71	; SQR()
_fac1_fac2_to_the_power_of_memYYAA	= $bf78
_fac1_negate			= $bfb4


; tables of squares
; sqr(x) = x ^ 2 / 4
sqrlo           = $c000
sqrhi           = $c200

; negsqr(x) = (255 - x) ^ 2 / 4
negsqrlo        = $c400
negsqrhi        = $c600

;pointers to square tables above
p_sqr_lo = $8b;2 bytes
p_sqr_hi = $8d;2 bytes
p_invsqr_lo = $8f;2 bytes
p_invsqr_hi = $91;2 bytes


    
;the inputs and outputs

;multiplier, 2 bytes;
x0=$fc;
x1=$fd;
;multiplier, 2 bytes
y0=$85;
y1=$86;

mul16_sign = $80    ; temporal variable to store the sign of the mul 16 multiplication
z0=$81
z1=$82

;z2=$83 returned in X reg
;z3=$84 returned in Y reg

!macro movA @val {
    lda #<@val      
    sta x0
    lda #>@val
    sta x1
}

!macro movX @val {
    lda #<@val      
    sta y0
    lda #>@val
    sta y1
}


!macro twoscomplement @val {
    clc
    lda @val
    eor #$ff
    adc #$01
    sta @val
    
    lda @val+1
    eor #$ff
    adc #$00
    sta @val+1
}


!macro print @st {
    lda #<@st
    ldy #>@st
    jsr KernalPrintYYAA
}

!macro println @st {
    lda #<@st
    ldy #>@st
    jsr KernalPrintYYAA
    jsr KernalNewLine
}

init16:
    jsr maketables
    rts

; x = -x
neg16:
    +twoscomplement x0
    rts

; x = x + y
add16:
    clc
    lda y0      ; high endian
    adc x0
    sta x0
    lda y1
    adc x1
    sta x1
    rts

; x = x - y
sub16:
    +twoscomplement y0
    jsr add16
    +twoscomplement y0
    rts


mul16:
    ldx #0              ; sign of the result
    lda x1              ; high endian
    bpl .pos_x
    +twoscomplement x0
    inx                 ; switch sign
.pos_x:
    lda y1
    bpl .pos_y
    +twoscomplement y0
    inx                 ; switch sign
.pos_y:
    stx mul16_sign
    jsr umult16
    lda mul16_sign
    and #$01            ; check is sign is odd
    beq .q
    +twoscomplement z0  ; product = -product
.q
    lda z0
    sta x0
    lda z1
    sta x1
    rts

printA:
    lda x0
    sta z0
    lda x1
    sta z1
    bpl .pos_z
    +twoscomplement z0
    +print minus
.pos_z
    ldx z0
    lda z1

    jsr _fac1_print_unsignedAAXX
    jsr KernalNewLine
   
    rts

minus: !text "-" 
!by 0

hello: !text "YOU FOUND 10 PIECES OF GOLD." 
!by 0

maketables:
;init zp square tables pointers
lda #<sqrlo
sta p_sqr_lo
lda #>sqrlo
sta p_sqr_lo+1

lda #<sqrhi
sta p_sqr_hi
lda #>sqrhi
sta p_sqr_hi+1

lda #<negsqrlo
sta p_invsqr_lo
lda #>negsqrlo
sta p_invsqr_lo+1

lda #<negsqrhi
sta p_invsqr_hi
lda #>negsqrhi
sta p_invsqr_hi+1

;generate sqr(x)=x^2/4
      ldx #$00
      txa
      !by $c9   ; CMP #immediate - skip TYA and clear carry flag
lb1:  tya
      adc #$00
ml1:  sta sqrhi,x
      tay
      cmp #$40
      txa
      ror
ml9:  adc #$00
      sta ml9+1
      inx
ml0:  sta sqrlo,x
      bne lb1
      inc ml0 + 2
      inc ml1 + 2
      clc
      iny
      bne lb1

;generate negsqr(x)=(255-x)^2/4
      ldx #$00
      ldy #$ff
mt1:
      lda sqrhi+1,x
      sta negsqrhi+$100,x
      lda sqrhi,x
      sta negsqrhi,y
      lda sqrlo+1,x
      sta negsqrlo+$100,x
      lda sqrlo,x
      sta negsqrlo,y
      dey
      inx
      bne mt1
      rts

umult16:
;set multiplier as x0
lda x0
sta p_sqr_lo
sta p_sqr_hi
eor #$ff
sta p_invsqr_lo
sta p_invsqr_hi;17

ldy y0
sec
lda (p_sqr_lo),y
sbc (p_invsqr_lo),y;note these two lines taken as 11 total
sta z0;x0*y0l
lda (p_sqr_hi),y
sbc (p_invsqr_hi),y
sta c1a+1;x0*y0h;31
;c1a means column 1, row a (partial product to be added later)

ldy y1
;sec  ;notice that the high byte of sub above is always +ve
lda (p_sqr_lo),y
sbc (p_invsqr_lo),y
sta c1b+1;x0*y1l
lda (p_sqr_hi),y
sbc (p_invsqr_hi),y
sta c2a+1;x0*y1h;31

;set multiplier as x1
lda x1
sta p_sqr_lo
sta p_sqr_hi
eor #$ff
sta p_invsqr_lo
sta p_invsqr_hi;17

ldy y0
;sec
lda (p_sqr_lo),y
sbc (p_invsqr_lo),y
sta c1c+1;x1*y0l
lda (p_sqr_hi),y
sbc (p_invsqr_hi),y
sta c2b+1;x1*y1h;31

ldy y1
;sec
lda (p_sqr_lo),y
sbc (p_invsqr_lo),y
sta c2c+1;x1*y1l
lda (p_sqr_hi),y
sbc (p_invsqr_hi),y
tay;x1*y1h;Y=z3, 30 cycles
;17+33+31+17+31+30=159 cycles for main multiply part

;jmp do_adds; can put do_adds in zp for a slight speed increase
do_adds:
;-add the first two numbers of column 1
    clc
c1a:	lda #0
c1b:	adc #0
    sta z1;9

;-continue to first two numbers of column 2
c2a:	lda #0
c2b:	adc #0
    tax;X=z2, 6 cycles
    bcc c1c;3/6 avg 4.5
    iny;z3++
    clc

;-add last number of column 1
c1c:	lda #0
    adc z1
    sta z1;8

;-add last number of column 2
    txa;A=z2
c2c:	adc #0
    tax;X=z2, 6
    bcc fin;3/4 avg 3.5
    iny;z3++

;Y=z3, X=z2
;9+6+4.5+8+6+3.5=37
fin:	rts

; Diagram of the additions
;                 y1    y0
;              x  x1    x0
;                 --------
;              x0y0h x0y0l
; +      x0y1h x0y1l
; +      x1y0h x1y0l
; +x1y1h x1y1l
; ------------------------
;     z3    z2    z1    z0   