; http://www.6502.org/tutorials/6502opcodes.html
; https://sites.google.com/site/6502asembly/6502-instruction-set
    

;https://github.com/meonwax/acme/blob/master/docs/AddrModes.txt
; Applying the byte extraction operators ("<" gives the low byte, ">"
; gives the high byte and "^" gives the bank byte of a value) to any
; value will clear the argument's Force Bits 2 and 3 and set Force
; Bit 1 instead. So "lda <symbol" will use 8-bit addressing, regardless
; of the symbol's Force Bits. Of course, you can change this by
; postfixing the command again... :

    ; * = $0801                               ; BASIC start address (#2049)
    ; !byte $0d,$08,$dc,$07,$9e,$20,$34,$39   ; BASIC loader to start at $c000...
    ; !byte $31,$35,$32,$00,$00,$00           ; puts BASIC line 2012 SYS 49152

KernalPrintYYAA = $AB1E ; prints string located at YYAA
KernalNewLine   = $AAD7 ; prints new line

_fac1_print			= $aabc	; print string representation of contents of fac1
_fac1_to_signedAAYY		= $b1aa	; might throw ILLEGAL QUANTITY
_fac1_to_signed16		= $b1bf	; might throw ILLEGAL QUANTITY
_fac1_read_signedAAYY		= $b391	; convert 16 bit signed int to float
_fac1_read_unsignedY		= $b3a2	; convert 8 bit unsigned int to float
_fac1_read_string		= $b7b5	; $22/23 must point to string, A must be string length
_fac1_to_unsignedAAYY		= $b7f7	; might throw ILLEGAL QUANTITY (result is also in $14/15)
_fac1_add_point5			= $b849	; for rounding, call this before fac1_int
_fac1_memYYAA_minus_fac1		= $b850	; subtract fac1 from mflpt value
_fac1_fac2_minus_fac1		= $b853
_fac1_add_memYYAA		= $b867	; add mflpt value
_fac1_add_fac2			= $b86a
_fac1_log			= $b9ea	; LOG()
_fac1_times_memYYAA		= $ba28	; multiply by mflpt value
_fac2_read_memYYAA		= $ba8c	; load mflpt value from memory into fac2
_fac2_read_mem_via0x22ptr	= $ba90	; load mflpt value from memory into fac2
_fac1_times_10			= $bae2
_fac1_divide_by_10		= $bafe	; CAUTION: result is always positive!
_fac1_divide_memYYAA_by_fac1	= $bb0f	; divide mflpt value by fac1 value
_fac1_read_memYYAA		= $bba2	; load mflpt value from memory into fac1
_fac1_read_mem_via0x22ptr	= $bba6	; load mflpt value from memory into fac1
_fac1_to_memYYXX			= $bbd4	; store fac1 to memory as mflpt
_fac1_read_fac2			= $bbfc	; copy fac2 to fac1
_fac2_read_fac1			= $bc0c	; copy fac1 to fac2
_fac1_sign_to_A			= $bc2b	; $ff, $0, $1 for negative, zero, positive
_fac1_sgn			= $bc39 ; SGN()
_fac1_abs			= $bc58 ; ABS()
_fac1_compare_to_memYYAA		= $bc5b	; compare to mflpt value in memory
_fac1_to_signed32		= $bc9b
_fac1_int			= $bccc ; INT()
_fac1_read_string0		= $bcf3	; use b7b5 instead; this only works after calling CHRGET
_fac1_print_unsignedAAXX		= $bdcd
_fac1_to_string			        = $bddd	; string is stored at $0100 (address returned in YYAA)
_fac1_sqr			        = $bf71	; SQR()
_fac1_fac2_to_the_power_of_memYYAA	= $bf78
_fac1_negate			        = $bfb4


; tables of squares
; sqr(x) = x ^ 2 / 4
sqrlo           = $c000
sqrhi           = $c200

; negsqr(x) = (255 - x) ^ 2 / 4
negsqrlo        = $c400
negsqrhi        = $c600

;pointers to square tables above
square1_lo = $8b;2 bytes
square1_hi = $8d;2 bytes
square2_lo = $8f;2 bytes
square2_hi = $91;2 bytes


    
;the inputs and outputs

;multiplier, 2 bytes;
x0=$c895;
x1=$c896;
;multiplier, 2 bytes
y0=$c890;
y1=$c891;

mul16_sign = $c880    ; temporal variable to store the sign of the mul 16 multiplication
z0=$c881
z1=$c882
z2=$c883
z3=$c884

;z2=$83 returned in X reg
;z3=$84 returned in Y reg

!macro movA @val {
        lda #<@val      
        sta x0
        lda #>@val
        sta x1
}

!macro movX @val {
        lda #<@val      
        sta y0
        lda #>@val
        sta y1
}


!macro twoscomplement @val {
        clc
        lda @val
        eor #$ff
        adc #$01
        sta @val
        
        lda @val+1
        eor #$ff
        adc #$00
        sta @val+1
}



!macro println @st {
        lda #<@st
        ldy #>@st
        jsr KernalPrintYYAA
        jsr KernalNewLine
}


!macro test_mul @X, @Y {
    lda #<@X
    sta x0
    lda #>@X
    sta x1
    
    lda x1
    jsr PRBYTE
    lda x0
    jsr PRBYTE

    jsr PRSPACE
    jsr prtimes
    jsr PRSPACE

    lda #<@Y
    sta y0
    lda #>@Y
    sta y1

    lda y1
    jsr PRBYTE
    lda y0
    jsr PRBYTE

    jsr PRSPACE
    jsr preq
    jsr PRSPACE

    jsr umult16

    lda z3
    jsr PRBYTE
    lda z2
    jsr PRBYTE
    lda z1
    jsr PRBYTE
    lda z0
    jsr PRBYTE

    jsr KernalNewLine
}

init16:
        jsr maketables
        rts

; x = -x
neg16:
        +twoscomplement x0
        rts

; x = x + y
add16:
        clc
        lda y0
        adc x0
        sta x0
        lda y1
        adc x1
        sta x1
        rts

; x = x - y
sub16:
        +twoscomplement y0
        jsr add16
        +twoscomplement y0
        rts


mul16:
        ldx #0              ; sign of the result
        lda x1             
        bpl .pos_x
        +twoscomplement x0
        inx                 ; switch sign
.pos_x:
        lda y1
        bpl .pos_y
        +twoscomplement y0
        inx                 ; switch sign
.pos_y:
        stx mul16_sign
        jsr umult16

        ; shift down result with 8 bits
        lda z1
        sta x0
        ;stx x1
        lda z2
        sta x1

        lda mul16_sign
        and #$01            ; check if sign is odd
        beq .q
        +twoscomplement x0  ; product = -product
.q
        rts

printA:
        lda x0
        sta z0
        lda x1
        sta z1
        bpl .pos_z
        +twoscomplement z0
    ; +print minus
.pos_z
        ldx z0
        lda z1

        jsr _fac1_print_unsignedAAXX
        jsr KernalNewLine
    
        rts

minus: 
        !text "-" 
        !by 0



maketables:
;init zp square tables pointers
        lda #<sqrlo
        sta square1_lo
        lda #>sqrlo
        sta square1_lo+1

        lda #<sqrhi
        sta square1_hi
        lda #>sqrhi
        sta square1_hi+1

        lda #<negsqrlo
        sta square2_lo
        lda #>negsqrlo
        sta square2_lo+1

        lda #<negsqrhi
        sta square2_hi
        lda #>negsqrhi
        sta square2_hi+1

        ldx #$00
        txa
        !by $c9   ; CMP #immediate - skip TYA and clear carry flag
lb1:    tya
        adc #$00
ml1:    sta sqrhi,x
        tay
        cmp #$40
        txa
        ror
ml9:    adc #$00
        sta ml9+1
        inx
ml0:    sta sqrlo,x
        bne lb1
        inc ml0+2
        inc ml1+2
        clc
        iny
        bne lb1

        ldx #$00
        ldy #$ff
.mt1:
        lda sqrhi+1,x
        sta negsqrhi+$100,x
        lda sqrhi,x
        sta negsqrhi,y
        lda sqrlo+1,x
        sta negsqrlo+$100,x
        lda sqrlo,x
        sta negsqrlo,y
        dey
        inx
        bne .mt1
        rts

umult16:
                ; <T1 * <T2 = AAaa 
                ; <T1 * >T2 = BBbb 
                ; >T1 * <T2 = CCcc 
                ; >T1 * >T2 = DDdd 
                ;                  
                ;       AAaa       
                ;     BBbb         
                ;     CCcc         
                ; + DDdd           
                ; ----------       
                ;   PRODUCT!       

                lda x0           
                sta sm1a+1       
                sta sm3a+1       
                sta sm5a+1       
                sta sm7a+1       
                eor #$ff         
                sta sm2a+1       
                sta sm4a+1       
                sta sm6a+1       
                sta sm8a+1       
                lda x1           
                sta sm1b+1       
                sta sm3b+1       
                sta sm5b+1       
                sta sm7b+1       
                eor #$ff         
                sta sm2b+1       
                sta sm4b+1       
                sta sm6b+1       
                sta sm8b+1       

                ; Perform <T1 * <T2 = AAaa
                ldx y0           
                sec              
sm1a:           lda sqrlo,x      
sm2a:           sbc negsqrlo,x   
                sta z0           
sm3a:           lda sqrhi,x      
sm4a:           sbc negsqrhi,x   
                sta _AA + 1      

                ; Perform >T1_hi * <T2 = CCcc
                sec              
sm1b:           lda sqrlo,x      
sm2b:           sbc negsqrlo,x   
                sta _cc + 1      
sm3b:           lda sqrhi,x      
sm4b:           sbc negsqrhi,x   
                sta _CC + 1      

                ; Perform <T1 * >T2 = BBbb
                ldx y1                    
                sec                       
sm5a:           lda sqrlo,x          
sm6a:           sbc negsqrlo,x          
                sta _bb + 1               
sm7a:           lda sqrhi,x          
sm8a:           sbc negsqrhi,x          
                sta _BB + 1               

                ; Perform >T1 * >T2 = DDdd
                sec                  
sm5b:           lda sqrlo,x          
sm6b:           sbc negsqrlo,x       
                sta _dd + 1          
sm7b:           lda sqrhi,x          
sm8b:           sbc negsqrhi,x       
                sta z3               

                ; Add the separate multiplications together
                clc                  
_AA:            lda #0               
_bb:            adc #0               
                sta z1               
_BB:            lda #0               
_CC:            adc #0               
                sta z2               
                bcc qqq1             
                inc z3               
                clc                  
qqq1:                                
_cc:            lda #0               
                adc z1               
                sta z1               
_dd:            lda #0               
                adc z2               
                sta z2               
                bcc qqq2             
                inc z3               
qqq2:                                
                rts
;umult16:
;         ;set multiplier as x0
;         lda x0
;         sta square1_lo
;         sta square1_hi
;         eor #$ff
;         sta square2_lo
;         sta square2_hi

;         ldy y0
;         sec
;         lda (square1_lo),y
;         sbc (square2_lo),y
;         sta z0 ; x0 * y0l
;         lda (square1_hi),y
;         sbc (square2_hi),y
;         sta c1a + 1 ;x0 * y0h;
;         ;c1a means column 1, row a (partial product to be added later)

;         ldy y1
;         ;sec  ;notice that the high byte of sub above is always +ve
;         lda (square1_lo),y
;         sbc (square2_lo),y
;         sta c1b+1;x0*y1l
;         lda (square1_hi),y
;         sbc (square2_hi),y
;         sta c2a+1;x0*y1h;31

;         ;set multiplier as x1
;         lda x1
;         sta square1_lo
;         sta square1_hi
;         eor #$ff
;         sta square2_lo
;         sta square2_hi;17

;         ldy y0
;         ;sec
;         lda (square1_lo),y
;         sbc (square2_lo),y
;         sta c1c+1;x1*y0l
;         lda (square1_hi),y
;         sbc (square2_hi),y
;         sta c2b+1;x1*y1h;31

;         ldy y1
;         ;sec
;         lda (square1_lo),y
;         sbc (square2_lo),y
;         sta c2c+1;x1*y1l
;         lda (square1_hi),y
;         sbc (square2_hi),y
;         tay;x1*y1h;Y=z3, 30 cycles
;         ;17+33+31+17+31+30=159 cycles for main multiply part

; ;jmp do_adds; can put do_adds in zp for a slight speed increase
; do_adds:
; ;-add the first two numbers of column 1
;         clc
; c1a:    lda #0
; c1b:    adc #0
;         sta z1;9

; ;-continue to first two numbers of column 2
; c2a:    lda #0
; c2b:    adc #0
;         tax;X=z2, 6 cycles
;         bcc c1c;3/6 avg 4.5
;         iny;z3++
;         clc

; ;-add last number of column 1
; c1c:    lda #0
;         adc z1
;         sta z1;8

; ;-add last number of column 2
;         txa;A=z2
; c2c:    adc #0
;         tax;X=z2, 6
;         bcc fin;3/4 avg 3.5
;         iny;z3++

; ;Y=z3, X=z2
; fin:    rts

; Diagram of the additions
;                 y1    y0
;              x  x1    x0
;                 --------
;              x0y0h x0y0l
; +      x0y1h x0y1l
; +      x1y0h x1y0l
; +x1y1h x1y1l
; ------------------------
;     z3    z2    z1    z0   



!macro print @st {
    lda #<@st
    ldy #>@st
    jsr $AB1E ; prints string located at YYAA
    jsr $AAD7 ; prints new line
}

preq:
        lda     #"="     
        JSR     $ffd2           ;kernel character output sub
        rts

prtimes:
        lda     #"*"     
        JSR     $ffd2           ;kernel character output sub
        rts

PRSPACE:
        lda     #" "     
        JSR     $ffd2           ;kernel character output sub
        rts

; https://gist.github.com/nobuh/1161983
PRBYTE:
                PHA                     ;Save A for LSD
                LSR
                LSR
                LSR                     ;MSD to LSD position
                LSR
                JSR     PRHEX           ;Output hex digit
                PLA                     ;Restore A

; Fall through to print hex routine

;-------------------------------------------------------------------------
;  Subroutine to print a hexadecimal digit
;-------------------------------------------------------------------------

PRHEX:          AND     #%00001111      ;Mask LSD for hex print
                ORA     #$30            ;Add "0"
                CMP     #$39+1          ;Is it a decimal digit?
                BCC     ECHO            ;Yes! output it
                ADC     #6              ;Add offset for letter A-F

; Fall through to print routine

;-------------------------------------------------------------------------
;  Subroutine to print a character to the terminal
;-------------------------------------------------------------------------

ECHO:       
                JSR     $ffd2           ;kernel character output sub    
                RTS