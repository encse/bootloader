; http://www.6502.org/tutorials/6502opcodes.html
; https://sites.google.com/site/6502asembly/6502-instruction-set
; https://github.com/meonwax/acme/tree/master/docs

    
    !to "mandelbrot.prg",cbm
!set FIXPOINT = 1
     *= $1500
     !src "fixpoint.a"

   ; 
    
    
    ; * = $0801                               ; BASIC start address (#2049)
    ; !byte $0d,$08,$dc,$07,$9e,$20,$34,$39   ; BASIC loader to start at $c000...
    ; !byte $31,$35,$32,$00,$00,$00           ; puts BASIC line 2012 SYS 49152

bmpage = $ff
mask = $59
loc = $5a
store = $5c

!macro fpmov @dst, @src {
    lda @src
    sta @dst
    lda @src + 1
    sta @dst + 1
}

!macro fpadd @dst, @src {
    clc
    lda @src
    adc @dst
    sta @dst
    lda @src+1
    adc @dst+1
    sta @dst+1
}

!macro fpsub @dst, @src {
    sec
    lda @dst
    sbc @src
    sta @dst
    lda @dst+1
    sbc @src+1
    sta @dst+1

}

!macro fpmul @dst, @src {
    lda @src
    sta x0
    lda @src + 1
    sta x1

    lda @dst
    sta y0
    lda @dst + 1
    sta y1

    jsr mul16

    lda x0
    sta @dst
    lda x1
    sta @dst + 1

}


mul16:
        ldx #0              ; sign of the result
        lda x1             
        bpl .pos_x
        +twoscomplement x0
        inx                 ; switch sign
.pos_x:
        lda y1
        bpl .pos_y
        +twoscomplement y0
        inx                 ; switch sign
.pos_y:
        stx mul16_sign
        jsr umult16

        ; shift down result with 8 bits
        lda z1
        sta x0
        ;stx x1
        lda z2
        sta x1

        lda mul16_sign
        and #$01            ; check if sign is odd
        beq .q
        +twoscomplement x0  ; product = -product
.q
        rts
        

;   maxIterations = 4
;   dc = 0.01
;   c2 = -1.0
;   for y in 0..200:
;       c1 = -2.0
;       for x in 0..320:
;           z1 = 0
;           z2 = 0
;           for i in 0..maxIterations:
;               tmp = z1 * z1 - z2 * z2 + c1
;               z2 = 2 * z1 * z2 + c2
;               z1 = tmp
;               if (z1 * z1 + z2 * z2 >= 4):
;                   setColor(x,y,i)
;                   break
;           c1 += dc
;       c2 += dc


    MAX_ITERATIONS = 14

    *= $1000
!if  FIXPOINT = 1   { 
    jsr init16
}

    jsr initGraphics

    lda #0
    sta y
.forY:
    ; c1 = c01
    +fpmov mflpt_c1, mflpt_c01
    ; for x in 0..320:
    
    ; x = 0
    lda #0
    sta x
.forX:
    ; z1 = z2 = z1^2 = z2^2 = 0
    +fpmov mflpt_z1, mflpt_0
    +fpmov mflpt_z2, mflpt_0
    +fpmov mflpt_z1Sq, mflpt_0
    +fpmov mflpt_z2Sq, mflpt_0

    ; for i in 0..maxIterations:
    ; i = 0
    lda #MAX_ITERATIONS
    sta i
.forI: 
    jsr updateZ
    bpl .nextX
.nextI:
    ldx i
    dex
    stx i
    bne .forI

    ; set x,y and also x, (200 - y) because of pattern symmetry
    jsr setPoint
    lda #172
    sbc y
    sta y

    jsr setPoint
    lda #172
    sbc y
    sta y

.nextX:
    ldx x
    inx 
    stx x
    beq .nextY

    +fpadd mflpt_c1, mflpt_dC

    jmp .forX
.nextY:
    ldx y
    inx 
    stx y
    beq .done

     ; c2 += dc
    +fpadd mflpt_c2, mflpt_dC

    jmp .forY
.done:

    rts

; compute z = z^2 + c, update z^2

updateZ:
    ; compute tmp = z1 * z1 - z2 * z2 + c1 
    
    +fpmov mflpt_tmp, mflpt_c1
    +fpadd mflpt_tmp, mflpt_z1Sq
    +fpsub mflpt_tmp, mflpt_z2Sq

    ;+dump_mflpt mflpt_c1

    ; now compute z2 = 2 * z1 * z2 + c2
    ; fac1 = z1

    +movYYAA mflpt_z1
    jsr fac1_read_memYYAA

    ; fac1 = 2 * z1
    +movYYAA mflpt_z1
    jsr fac1_add_memYYAA

    ; fac1 = 2 * z1 * z2
    +movYYAA mflpt_z2
    jsr fac1_times_memYYAA

    ; fac1 = 2 * z1 * z2 + c2
    +movYYAA mflpt_c2
    jsr fac1_add_memYYAA

    ; z2 = 2 * z1 * z2 + c2
    +movYYXX mflpt_z2
    jsr fac1_to_memYYXX

    ; z1 = tmp
    +fpmov mflpt_z1, mflpt_tmp

    ; update z1^2 and z2^2
    +fpmov mflpt_z1Sq, mflpt_z1
    +fpmul mflpt_z1Sq, mflpt_z1Sq
    +fpmov mflpt_z2Sq, mflpt_z2
    +fpmul mflpt_z2Sq, mflpt_z2Sq

    ; fac1 = z1 * z1 + z2 * z2
    +fpmov mflpt_tmp, mflpt_z1Sq
    +fpadd mflpt_tmp, mflpt_z2Sq
    +fpsub mflpt_tmp, mflpt_4
    rts

setPoint:
    ; https://github.com/spoitras/High-resolution-plot-sub-routine/blob/master/plot.asm
    ; address = base + int(y/8) * 320 + (y and 7) + int(x/8) * 8
    lda	x
    and	#7
    tax
    sec
    lda	#0
    sta loc
.shift:	
    ror
    dex
    bpl .shift
    sta mask
    lda x
    and #$f8
    sta store
    lda y
    lsr
    lsr
    lsr
    sta loc+1
    lsr
    ror	loc
    lsr
    ror	loc
    adc loc+1
    sta loc+1
    lda y
    and #7
    adc loc
    adc store
    sta loc
    lda loc+1
    adc x+1
    adc bmpage
    sta loc+1
    ldy	#0
    lda (loc),y
    ora mask,y
    sta (loc),y
    rts


initGraphics:
    ; Toggle standard Bitmap Mode 
    lda $d018 ; 53272
    ora #8
    sta $d018

    lda $d011 ; 53265
    ora #32
    sta $d011

    ; Set colors
    ldx #0
    lda #14
.setColor:
    ; $0400-$07ff screen ram
    sta $400, X
    sta $500, X
    sta $600, X
    sta $700, X  
    inx
    bne .setColor

    ; Clear screen
    ldx #0
    lda #0 
.clearScreen:
    ;$2000 - $3fff: Bitmap RAM
    sta $2000, X
    sta $2100, X
    sta $2200, X
    sta $2300, X
    sta $2400, X
    sta $2500, X
    sta $2600, X
    sta $2700, X
    sta $2800, X
    sta $2900, X
    sta $2a00, X
    sta $2b00, X
    sta $2c00, X
    sta $2d00, X
    sta $2e00, X
    sta $2f00, X
    sta $3000, X
    sta $3100, X
    sta $3200, X
    sta $3300, X
    sta $3400, X
    sta $3500, X
    sta $3600, X
    sta $3700, X
    sta $3800, X
    sta $3900, X
    sta $3a00, X
    sta $3b00, X
    sta $3c00, X
    sta $3d00, X
    sta $3e00, X
    sta $3f00, X
    inx
    bne .clearScreen
    
    rts


st_nextX: !text "nextX" 
!by 0
st_nextY: !text "nextY" 
!by 0

x:            !word 0
y:            !word 0
i:            !word 0
mflpt_4:      +mflpt  4.0
mflpt_0:      +mflpt  0.0
mflpt_dC:     +mflpt  0.01
mflpt_c01:    +mflpt -2.0
mflpt_c1:     +mflpt  0.0
mflpt_c2:     +mflpt -1.0
mflpt_z1:     +mflpt  0.0
mflpt_z1Sq:   +mflpt  0.0
mflpt_z2:     +mflpt  0.0
mflpt_z2Sq:   +mflpt  0.0
mflpt_tmp:    +mflpt  0.0


